#### 跨域：即协议不同或者域名不同或者端口不同  也就是所谓的同源策略

##### 1.图片ping

```javascript
var img = new Image()
img.scr="http://192.158.39/3;imagg.png"  // 加载其他地方的图片
img.onerror=function(){
    console.log('失败')
}
img.onload = function(){
    console.log('成功')
}
以上会打印出'成功'
```

##### 缺点：使用图片ping跨域只能发送==get==请求，并且不能访问响应的文本，只能监听是否响应而已，可以用来追踪广告点击。

#### 2.jsonp  jsonp是带有回调函数callback的json

```javascript
 //回调函数
 function showData (result) {
   var data = JSON.stringify(result); //json对象转成字符串
   $("#text").val(data);
 }
  $(document).ready(function () {
    $("#btn").click(function () {
      //向头部输入一个脚本，该脚本发起一个跨域请求
      $("head").append("<script src='http://localhost:9090/student?callback=showData'><\/script>");
    });

  });

// jquery 的jsonp请求
function showData (data) {
  console.info("调用showData");

  var result = JSON.stringify(data);
  $("#text").val(result);
}

$(document).ready(function () {
  $("#btn").click(function () {
    $.ajax({
      url: "http://localhost:9090/student",
      type: "GET",
      dataType: "jsonp",  //指定服务器返回的数据类型
      jsonp:"theFn",      // 指定参数名称，这样后台接受的参数就不再是showData而是theFn 类似:String callback = request.getParameter("theFunction");
      jsonpCallback: "showData",  //指定回调函数名称
      success: function (data) {
        console.info("调用success");
      }
    });
  });
```

##### 缺点：因此使用jsonp时也只能使用==GET==方式发起跨域请求。跨域请求需要服务端配合，设置==callback==，才能完成跨域请求。 

#### 3.CORS 跨资源共享

```javascript
HTTP Header
Request header:
Origin头在跨域请求或预先请求中，标明发起跨域请求的源域名。
Access-Control-Request-Method头用于表明跨域请求使用的实际HTTP方法
Access-Control-Request-Headers用于在预先请求时，告知服务器要发起的跨域请求中会携带的请求头信息

Response header:
Access-Control-Allow-Origin: *  // Access-Control-Allow-Origin头中携带了服务器端验证后的允许的跨域请求域名，可以是一个具体的域名或是一个*（表示任意域名）。简单请求时，浏览器会根据此响应头的内容决定是否给脚本返回相应内容，预先验证请求时，浏览器会根据此响应头决定是否发送实际的跨域请求。
Access-Control-Allow-Methods: POST, GET, OPTIONS // Access-Control-Allow-Methods用于告知浏览器可以在实际发送跨域请求时，可以支持的请求方法，可以是一个具体的方法列表或是一个*（表示任意方法）。简单请求时，浏览器会根据此响应头的内容决定是否给脚本返回相应内容，预先验证请求时，浏览器会根据此响应头决定是否发送实际的跨域请求
Access-Control-Expose-Headers头用于允许返回给跨域请求的响应头列表，在列表中的响应头的内容，才可以被浏览器访问。
Access-Control-Allow-Credentials:true,   // Access-Control-Allow-Credentials用于告知浏览器当withCredentials属性设置为true时，是否可以显示跨域请求返回的内容。简单请求时，浏览器会根据此响应头决定是否显示响应的内容。预先验证请求时，浏览器会根据此响应头决定在发送实际跨域请求时，是否携带认证信息。
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type  // Access-Control-Allow-Headers用于告知浏览器可以在实际发送跨域请求时，可以支持的请求头，可以是一个具体的请求头列表或是一个*（表示任意请求头）。简单请求时，浏览器会根据此响应头的内容决定是否给脚本返回相应内容，预先验证请求时，浏览器会根据此响应头决定是否发送实际的跨域请求。 
Access-Control-Max-Age: 86400
```

#### 所谓的简单请求与复杂请求

##### 简单请求

1. ##### 使用方法在GET  OPTIONS POST之一

2. ##### Http头信息不超过以下几种字段Accept

   Accept-Language

   Content-Language

   Content-Type:值属于下列之一:

   - `application/x-www-form-urlencoded`
   - `multipart/form-data`
   - `text/plain` 

#####     3.浏览器与服务器之间只请求了一次

#####   复杂请求：不满足简单请求条件的请求则要先进行预检请求，即使用==OPTIONS方法发起一个预检请求==到服务器，已获知服务器是否允许该实际请求。

##### 如何发送一个想携带cookie或者token的请求

```javascript
// 注意：服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 '*' 。
function createCORSRequest(method, url) {
    var xhr = new XMLHttpRequest();
    xhr.onload = function() {
        if(xhr.readyState == 4) {
            try {
                if((xhr.status >= 200 && xhr.status < 300) || xhr == 304) {
                    console.log(xhr.response);
                } else {
                    console.log('Request was unsuccessful: ' + xhr.status);
                }
            } catch(ex) {
                new Error(ex);
            }
        }
    };
    if('withCredentials' in xhr) {  // 判断时候用withCredentials
        xhr.open(method,url, true);
    } else if(typeof XDomainRequest != 'undefined') {
        xhr = new XDomainRequest();
        xhr.open(method, url);
    } else {
        xhr = null;
    }
    return xhr;
}

// 使用jquery
$.ajax({
  url:'http://192.168.0.22:9000/content',
  data:data,
  dataType:'json',
  contentType:'application/json',
  type:'POST',
  xhrFields: {
    withCredentials: true  // 表示发送Ajax时，Request header中便会带上 Cookie 信息。
  }
})
// 服务器端也要做相应的调整
 response.setHeader("Access-Control-Allow-Credentials", "true");
```

