<template><p>![image-20191220194051543](/Users/sundong/Library/Application Support/typora-user-images/image-20191220194051543.png)</p>
<h4 id="对称加密-aes"><a class="header-anchor" href="#对称加密-aes">#</a> 对称加密（aes）</h4>
<p>对于对称加密客户端与服务端公用<code>同一个密钥</code>，虽然我们在后续的通信中对明文进行了加密，<code>但是第一次约定加密方式和密钥的通信仍然是明文</code>，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容</p>
<h4 id="非对称加密-rsa"><a class="header-anchor" href="#非对称加密-rsa">#</a> 非对称加密（rsa）</h4>
<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密</p>
<p>![image-20200820112001829](/Users/sundong/Library/Application Support/typora-user-images/image-20200820112001829.png)</p>
<p>图中第7处表述有问题，应该是通过A公钥加密发给服务器。</p>
<h4 id="数字证书"><a class="header-anchor" href="#数字证书">#</a> 数字证书</h4>
<p>1.服务端把自己的公钥发给证书颁发机构申请证书</p>
<p>2.证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端</p>
<p>3.当客户端请求时，服务端不在返回自己的公钥，而是把申请的证书返回给客户端</p>
<p>4.客户端收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，<strong>各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥</strong>。所以客户端只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。按照同样的签名规则，自己也生成一个证书签名，如果证书签名一致，则说明证书是有效的</p>
<p>5.验证成功后客户端可以利用机构公钥解密出服务端的公钥</p>
<p>6.客户端生成自己的对称加密密钥，并且用服务端的公钥和加密方法返回给服务端</p>
<p>7.服务端通过自己的私钥解开加密，获得对称加密密钥</p>
<h5 id="以上证书的签名是有服务端网址等信息生成的-并且经过机构私钥加密-中间人无法篡改。"><a class="header-anchor" href="#以上证书的签名是有服务端网址等信息生成的-并且经过机构私钥加密-中间人无法篡改。">#</a> 以上证书的签名是有服务端网址等信息生成的，并且经过机构私钥加密，中间人无法篡改。</h5>
<p><a href="https://zhuanlan.zhihu.com/p/57142784" target="_blank" rel="noopener noreferrer">参考链接<OutboundLink/></a></p>
</template>