(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{407:function(t,a,s){"use strict";s.r(a);var e=s(45),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"如何理解前后端分离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何理解前后端分离"}},[t._v("#")]),t._v(" 如何理解前后端分离？")]),t._v(" "),s("h4",{attrs:{id:"一、什么是前后端分离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是前后端分离"}},[t._v("#")]),t._v(" 一、什么是前后端分离")]),t._v(" "),s("h5",{attrs:{id:"首先前端后端有两种协作方式-一种是服务器端渲染-另一种就是前后端分离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首先前端后端有两种协作方式-一种是服务器端渲染-另一种就是前后端分离"}},[t._v("#")]),t._v(" 首先前端后端有两种协作方式，一种是"),s("code",[t._v("服务器端渲染")]),t._v("，另一种就是"),s("code",[t._v("前后端分离")])]),t._v(" "),s("p",[t._v("1、服务器端渲染：是指在服务器端就把网页生成好，浏览器直接拿到的是一整个网页，css和js部分是在浏览器端进行的，而网页的部分是在服务器端生成的。浏览器与服务器之间传递的是html网页")]),t._v(" "),s("p",[t._v("2、前后端分离：浏览器先拿到html，然后和后台通过ajax获取数据。在这种方式下，浏览器与服务器之间传递的是数据")]),t._v(" "),s("h4",{attrs:{id:"二、前后端分离-vs-服务器端渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、前后端分离-vs-服务器端渲染"}},[t._v("#")]),t._v(" 二、前后端分离 vs 服务器端渲染")]),t._v(" "),s("p",[t._v("1、数据量：前端后分离传递的是数据，因此数据量相对较少；服务七段渲染传递的是html网页，传递的是大量的数据，并且很多是重复的")]),t._v(" "),s("p",[t._v("2、体验方面：前后端分离多了一个渲染的过程，也就是会导致首屏渲染的问题；服务器端并不会有这个问题")]),t._v(" "),s("p",[t._v("3、解耦：前后端分离过程中，传输的是数据，至于如何显示是由前端去处理，服务器端只提供数据即可；服务器端传输的是html网页，后端传给前端的Model，通常是通过Hidden的Input来处理，或者是直接用模板技术生成（JSP，Velocity，freemak）等。数据和页面展示并没有真正分离")]),t._v(" "),s("p",[t._v("4、控制：对于网页彼此之间的跳转交互，前后端分离过程中全部由前端去处理。而对于服务器渲染是需要后端去处理跳转")]),t._v(" "),s("p",[t._v("5、SEO：对于前后端分离方式，通常载体是SPA，导致SEO拿到的是一个没有数据的空壳子，很多搜索引擎不支持SPA方式的SEO")])])}),[],!1,null,null,null);a.default=r.exports}}]);